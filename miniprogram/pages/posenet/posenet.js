"use strict";var tfjs=require("../../chunks/tfjs.js");class BaseModel{constructor(model,outputStride){this.model=model;this.outputStride=outputStride;const inputShape=this.model.inputs[0].shape;tfjs.assert(inputShape[1]===-1&&inputShape[2]===-1,(()=>`Input shape [${inputShape[1]}, ${inputShape[2]}] must both be equal to or -1`))}predict(input){return tfjs.tidy((()=>{const asFloat=this.preprocessInput(tfjs.cast(input,"float32"));const asBatch=tfjs.expandDims(asFloat,0);const results=this.model.predict(asBatch);const results3d=results.map((y=>tfjs.squeeze(y,[0])));const namedResults=this.nameOutputResults(results3d);return{heatmapScores:tfjs.sigmoid(namedResults.heatmap),offsets:namedResults.offsets,displacementFwd:namedResults.displacementFwd,displacementBwd:namedResults.displacementBwd}}))}dispose(){this.model.dispose()}}class MobileNet extends BaseModel{preprocessInput(input){return tfjs.tidy((()=>tfjs.sub(tfjs.div(input,127.5),1)))}nameOutputResults(results){const[offsets,heatmap,displacementFwd,displacementBwd]=results;return{offsets:offsets,heatmap:heatmap,displacementFwd:displacementFwd,displacementBwd:displacementBwd}}}function half(k){return Math.floor(k/2)}class MaxHeap{constructor(maxSize,getElementValue){this.priorityQueue=new Array(maxSize);this.numberOfElements=-1;this.getElementValue=getElementValue}enqueue(x){this.priorityQueue[++this.numberOfElements]=x;this.swim(this.numberOfElements)}dequeue(){const max=this.priorityQueue[0];this.exchange(0,this.numberOfElements--);this.sink(0);this.priorityQueue[this.numberOfElements+1]=null;return max}empty(){return this.numberOfElements===-1}size(){return this.numberOfElements+1}all(){return this.priorityQueue.slice(0,this.numberOfElements+1)}max(){return this.priorityQueue[0]}swim(k){while(k>0&&this.less(half(k),k)){this.exchange(k,half(k));k=half(k)}}sink(k){while(2*k<=this.numberOfElements){let j=2*k;if(j<this.numberOfElements&&this.less(j,j+1)){j++}if(!this.less(k,j)){break}this.exchange(k,j);k=j}}getValueAt(i){return this.getElementValue(this.priorityQueue[i])}less(i,j){return this.getValueAt(i)<this.getValueAt(j)}exchange(i,j){const t=this.priorityQueue[i];this.priorityQueue[i]=this.priorityQueue[j];this.priorityQueue[j]=t}}function scoreIsMaximumInLocalWindow(keypointId,score,heatmapY,heatmapX,localMaximumRadius,scores){const[height,width]=scores.shape;let localMaximum=true;const yStart=Math.max(heatmapY-localMaximumRadius,0);const yEnd=Math.min(heatmapY+localMaximumRadius+1,height);for(let yCurrent=yStart;yCurrent<yEnd;++yCurrent){const xStart=Math.max(heatmapX-localMaximumRadius,0);const xEnd=Math.min(heatmapX+localMaximumRadius+1,width);for(let xCurrent=xStart;xCurrent<xEnd;++xCurrent){if(scores.get(yCurrent,xCurrent,keypointId)>score){localMaximum=false;break}}if(!localMaximum){break}}return localMaximum}function buildPartWithScoreQueue(scoreThreshold,localMaximumRadius,scores){const[height,width,numKeypoints]=scores.shape;const queue=new MaxHeap(height*width*numKeypoints,(({score:score})=>score));for(let heatmapY=0;heatmapY<height;++heatmapY){for(let heatmapX=0;heatmapX<width;++heatmapX){for(let keypointId=0;keypointId<numKeypoints;++keypointId){const score=scores.get(heatmapY,heatmapX,keypointId);if(score<scoreThreshold){continue}if(scoreIsMaximumInLocalWindow(keypointId,score,heatmapY,heatmapX,localMaximumRadius,scores)){queue.enqueue({score:score,part:{heatmapY:heatmapY,heatmapX:heatmapX,id:keypointId}})}}}}return queue}const partNames=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"];const NUM_KEYPOINTS=partNames.length;const partIds=partNames.reduce(((result,jointName,i)=>{result[jointName]=i;return result}),{});const connectedPartNames=[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]];const poseChain=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]];const connectedPartIndices=connectedPartNames.map((([jointNameA,jointNameB])=>[partIds[jointNameA],partIds[jointNameB]]));function getOffsetPoint$1(y,x,keypoint,offsets){return{y:offsets.get(y,x,keypoint),x:offsets.get(y,x,keypoint+NUM_KEYPOINTS)}}function getImageCoords(part,outputStride,offsets){const{heatmapY:heatmapY,heatmapX:heatmapX,id:keypoint}=part;const{y:y,x:x}=getOffsetPoint$1(heatmapY,heatmapX,keypoint,offsets);return{x:part.heatmapX*outputStride+x,y:part.heatmapY*outputStride+y}}function clamp(a,min,max){if(a<min){return min}if(a>max){return max}return a}function squaredDistance(y1,x1,y2,x2){const dy=y2-y1;const dx=x2-x1;return dy*dy+dx*dx}function addVectors(a,b){return{x:a.x+b.x,y:a.y+b.y}}const parentChildrenTuples=poseChain.map((([parentJoinName,childJoinName])=>[partIds[parentJoinName],partIds[childJoinName]]));const parentToChildEdges=parentChildrenTuples.map((([,childJointId])=>childJointId));const childToParentEdges=parentChildrenTuples.map((([parentJointId])=>parentJointId));function getDisplacement(edgeId,point,displacements){const numEdges=displacements.shape[2]/2;return{y:displacements.get(point.y,point.x,edgeId),x:displacements.get(point.y,point.x,numEdges+edgeId)}}function getStridedIndexNearPoint(point,outputStride,height,width){return{y:clamp(Math.round(point.y/outputStride),0,height-1),x:clamp(Math.round(point.x/outputStride),0,width-1)}}function traverseToTargetKeypoint(edgeId,sourceKeypoint,targetKeypointId,scoresBuffer,offsets,outputStride,displacements,offsetRefineStep=2){const[height,width]=scoresBuffer.shape;const sourceKeypointIndices=getStridedIndexNearPoint(sourceKeypoint.position,outputStride,height,width);const displacement=getDisplacement(edgeId,sourceKeypointIndices,displacements);const displacedPoint=addVectors(sourceKeypoint.position,displacement);let targetKeypoint=displacedPoint;for(let i=0;i<offsetRefineStep;i++){const targetKeypointIndices=getStridedIndexNearPoint(targetKeypoint,outputStride,height,width);const offsetPoint=getOffsetPoint$1(targetKeypointIndices.y,targetKeypointIndices.x,targetKeypointId,offsets);targetKeypoint=addVectors({x:targetKeypointIndices.x*outputStride,y:targetKeypointIndices.y*outputStride},{x:offsetPoint.x,y:offsetPoint.y})}const targetKeyPointIndices=getStridedIndexNearPoint(targetKeypoint,outputStride,height,width);const score=scoresBuffer.get(targetKeyPointIndices.y,targetKeyPointIndices.x,targetKeypointId);return{position:targetKeypoint,part:partNames[targetKeypointId],score:score}}function decodePose(root,scores,offsets,outputStride,displacementsFwd,displacementsBwd){const numParts=scores.shape[2];const numEdges=parentToChildEdges.length;const instanceKeypoints=new Array(numParts);const{part:rootPart,score:rootScore}=root;const rootPoint=getImageCoords(rootPart,outputStride,offsets);instanceKeypoints[rootPart.id]={score:rootScore,part:partNames[rootPart.id],position:rootPoint};for(let edge=numEdges-1;edge>=0;--edge){const sourceKeypointId=parentToChildEdges[edge];const targetKeypointId=childToParentEdges[edge];if(instanceKeypoints[sourceKeypointId]&&!instanceKeypoints[targetKeypointId]){instanceKeypoints[targetKeypointId]=traverseToTargetKeypoint(edge,instanceKeypoints[sourceKeypointId],targetKeypointId,scores,offsets,outputStride,displacementsBwd)}}for(let edge=0;edge<numEdges;++edge){const sourceKeypointId=childToParentEdges[edge];const targetKeypointId=parentToChildEdges[edge];if(instanceKeypoints[sourceKeypointId]&&!instanceKeypoints[targetKeypointId]){instanceKeypoints[targetKeypointId]=traverseToTargetKeypoint(edge,instanceKeypoints[sourceKeypointId],targetKeypointId,scores,offsets,outputStride,displacementsFwd)}}return instanceKeypoints}function withinNmsRadiusOfCorrespondingPoint(poses,squaredNmsRadius,{x:x,y:y},keypointId){return poses.some((({keypoints:keypoints})=>{const correspondingKeypoint=keypoints[keypointId].position;return squaredDistance(y,x,correspondingKeypoint.y,correspondingKeypoint.x)<=squaredNmsRadius}))}function getInstanceScore(existingPoses,squaredNmsRadius,instanceKeypoints){let notOverlappedKeypointScores=instanceKeypoints.reduce(((result,{position:position,score:score},keypointId)=>{if(!withinNmsRadiusOfCorrespondingPoint(existingPoses,squaredNmsRadius,position,keypointId)){result+=score}return result}),0);return notOverlappedKeypointScores/=instanceKeypoints.length}const kLocalMaximumRadius=1;function decodeMultiplePoses(scoresBuffer,offsetsBuffer,displacementsFwdBuffer,displacementsBwdBuffer,outputStride,maxPoseDetections,scoreThreshold=.5,nmsRadius=20){const poses=[];const queue=buildPartWithScoreQueue(scoreThreshold,kLocalMaximumRadius,scoresBuffer);const squaredNmsRadius=nmsRadius*nmsRadius;while(poses.length<maxPoseDetections&&!queue.empty()){const root=queue.dequeue();const rootImageCoords=getImageCoords(root.part,outputStride,offsetsBuffer);if(withinNmsRadiusOfCorrespondingPoint(poses,squaredNmsRadius,rootImageCoords,root.part.id)){continue}const keypoints=decodePose(root,scoresBuffer,offsetsBuffer,outputStride,displacementsFwdBuffer,displacementsBwdBuffer);const score=getInstanceScore(poses,squaredNmsRadius,keypoints);poses.push({keypoints:keypoints,score:score})}return poses}function mod(a,b){return tfjs.tidy((()=>{const floored=tfjs.div(a,tfjs.scalar(b,"int32"));return tfjs.sub(a,tfjs.mul(floored,tfjs.scalar(b,"int32")))}))}function argmax2d(inputs){const[height,width,depth]=inputs.shape;return tfjs.tidy((()=>{const reshaped=tfjs.reshape(inputs,[height*width,depth]);const coords=tfjs.argMax(reshaped,0);const yCoords=tfjs.expandDims(tfjs.div(coords,tfjs.scalar(width,"int32")),1);const xCoords=tfjs.expandDims(mod(coords,width),1);return tfjs.concat([yCoords,xCoords],1)}))}function getPointsConfidence(heatmapScores,heatMapCoords){const numKeypoints=heatMapCoords.shape[0];const result=new Float32Array(numKeypoints);for(let keypoint=0;keypoint<numKeypoints;keypoint++){const y=heatMapCoords.get(keypoint,0);const x=heatMapCoords.get(keypoint,1);result[keypoint]=heatmapScores.get(y,x,keypoint)}return result}function getOffsetPoint(y,x,keypoint,offsetsBuffer){return{y:offsetsBuffer.get(y,x,keypoint),x:offsetsBuffer.get(y,x,keypoint+NUM_KEYPOINTS)}}function getOffsetVectors(heatMapCoordsBuffer,offsetsBuffer){const result=[];for(let keypoint=0;keypoint<NUM_KEYPOINTS;keypoint++){const heatmapY=heatMapCoordsBuffer.get(keypoint,0).valueOf();const heatmapX=heatMapCoordsBuffer.get(keypoint,1).valueOf();const{x:x,y:y}=getOffsetPoint(heatmapY,heatmapX,keypoint,offsetsBuffer);result.push(y);result.push(x)}return tfjs.tensor2d(result,[NUM_KEYPOINTS,2])}function getOffsetPoints(heatMapCoordsBuffer,outputStride,offsetsBuffer){return tfjs.tidy((()=>{const offsetVectors=getOffsetVectors(heatMapCoordsBuffer,offsetsBuffer);return tfjs.add(tfjs.cast(tfjs.mul(heatMapCoordsBuffer.toTensor(),tfjs.scalar(outputStride,"int32")),"float32"),offsetVectors)}))}function decodeSinglePose(heatmapScores,offsets,outputStride){let totalScore=0;const heatmapValues=argmax2d(heatmapScores);const allTensorBuffers=[heatmapScores.bufferSync(),offsets.bufferSync(),heatmapValues.bufferSync()];const scoresBuffer=allTensorBuffers[0];const offsetsBuffer=allTensorBuffers[1];const heatmapValuesBuffer=allTensorBuffers[2];const offsetPoints=getOffsetPoints(heatmapValuesBuffer,outputStride,offsetsBuffer);const offsetPointsBuffer=offsetPoints.bufferSync();const keypointConfidence=Array.from(getPointsConfidence(scoresBuffer,heatmapValuesBuffer));const keypoints=keypointConfidence.map(((score,keypointId)=>{totalScore+=score;return{position:{y:offsetPointsBuffer.get(keypointId,0),x:offsetPointsBuffer.get(keypointId,1)},part:partNames[keypointId],score:score}}));heatmapValues.dispose();offsetPoints.dispose();return{keypoints:keypoints,score:totalScore/keypoints.length}}const MOBILENET_BASE_URL="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/";const RESNET50_BASE_URL="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function resNet50Checkpoint(stride,quantBytes){const graphJson=`model-stride${stride}.json`;if(quantBytes===4){return RESNET50_BASE_URL+`float/`+graphJson}else{return RESNET50_BASE_URL+`quant${quantBytes}/`+graphJson}}function mobileNetCheckpoint(stride,multiplier,quantBytes){const toStr={1:"100",.75:"075",.5:"050"};const graphJson=`model-stride${stride}.json`;if(quantBytes===4){return MOBILENET_BASE_URL+`float/${toStr[multiplier]}/`+graphJson}else{return MOBILENET_BASE_URL+`quant${quantBytes}/${toStr[multiplier]}/`+graphJson}}const imageNetMean=[-123.15,-115.9,-103.06];class ResNet extends BaseModel{preprocessInput(input){return tfjs.add(input,imageNetMean)}nameOutputResults(results){const[displacementFwd,displacementBwd,offsets,heatmap]=results;return{offsets:offsets,heatmap:heatmap,displacementFwd:displacementFwd,displacementBwd:displacementBwd}}}function eitherPointDoesntMeetConfidence(a,b,minConfidence){return a<minConfidence||b<minConfidence}function getAdjacentKeyPoints(keypoints,minConfidence){return connectedPartIndices.reduce(((result,[leftJoint,rightJoint])=>{if(eitherPointDoesntMeetConfidence(keypoints[leftJoint].score,keypoints[rightJoint].score,minConfidence)){return result}result.push([keypoints[leftJoint],keypoints[rightJoint]]);return result}),[])}function toTensorBuffers3D(tensors){return tensors.map((tensor=>tensor.bufferSync()))}function scalePose(pose,scaleY,scaleX,offsetY=0,offsetX=0){return{score:pose.score,keypoints:pose.keypoints.map((({score:score,part:part,position:position})=>({score:score,part:part,position:{x:position.x*scaleX+offsetX,y:position.y*scaleY+offsetY}})))}}function scalePoses(poses,scaleY,scaleX,offsetY=0,offsetX=0){if(scaleX===1&&scaleY===1&&offsetY===0&&offsetX===0){return poses}return poses.map((pose=>scalePose(pose,scaleY,scaleX,offsetY,offsetX)))}function flipPoseHorizontal(pose,imageWidth){return{score:pose.score,keypoints:pose.keypoints.map((({score:score,part:part,position:position})=>({score:score,part:part,position:{x:imageWidth-1-position.x,y:position.y}})))}}function flipPosesHorizontal(poses,imageWidth){if(imageWidth<=0){return poses}return poses.map((pose=>flipPoseHorizontal(pose,imageWidth)))}function toValidInputResolution(inputResolution,outputStride){if(isValidInputResolution(inputResolution,outputStride)){return inputResolution}return Math.floor(inputResolution/outputStride)*outputStride+1}function validateInputResolution(inputResolution){tfjs.assert(typeof inputResolution==="number"||typeof inputResolution==="object",(()=>`Invalid inputResolution ${inputResolution}. Should be a number or an object with width and height`));if(typeof inputResolution==="object"){tfjs.assert(typeof inputResolution.width==="number",(()=>`inputResolution.width has a value of ${inputResolution.width} which is invalid; it must be a number`));tfjs.assert(typeof inputResolution.height==="number",(()=>`inputResolution.height has a value of ${inputResolution.height} which is invalid; it must be a number`))}}function getValidInputResolutionDimensions(inputResolution,outputStride){validateInputResolution(inputResolution);if(typeof inputResolution==="object"){return[toValidInputResolution(inputResolution.height,outputStride),toValidInputResolution(inputResolution.width,outputStride)]}else{return[toValidInputResolution(inputResolution,outputStride),toValidInputResolution(inputResolution,outputStride)]}}const VALID_OUTPUT_STRIDES=[8,16,32];function assertValidOutputStride(outputStride){tfjs.assert(typeof outputStride==="number",(()=>"outputStride is not a number"));tfjs.assert(VALID_OUTPUT_STRIDES.indexOf(outputStride)>=0,(()=>`outputStride of ${outputStride} is invalid. It must be either 8, 16, or 32`))}function isValidInputResolution(resolution,outputStride){return(resolution-1)%outputStride===0}function assertValidResolution(resolution,outputStride){tfjs.assert(typeof resolution[0]==="number"&&typeof resolution[1]==="number",(()=>`both resolution values must be a number but had values ${resolution}`));tfjs.assert(isValidInputResolution(resolution[0],outputStride),(()=>`height of ${resolution[0]} is invalid for output stride ${outputStride}.`));tfjs.assert(isValidInputResolution(resolution[1],outputStride),(()=>`width of ${resolution[1]} is invalid for output stride ${outputStride}.`))}function getInputTensorDimensions(input){return input instanceof tfjs.Tensor?[input.shape[0],input.shape[1]]:[input.height,input.width]}function toInputTensor(input){return input instanceof tfjs.Tensor?input:tfjs.fromPixels(input)}function padAndResizeTo(input,[targetH,targetW]){const[height,width]=getInputTensorDimensions(input);const targetAspect=targetW/targetH;const aspect=width/height;let[padT,padB,padL,padR]=[0,0,0,0];if(aspect<targetAspect){padT=0;padB=0;padL=Math.round(.5*(targetAspect*height-width));padR=Math.round(.5*(targetAspect*height-width))}else{padT=Math.round(.5*(1/targetAspect*width-height));padB=Math.round(.5*(1/targetAspect*width-height));padL=0;padR=0}const resized=tfjs.tidy((()=>{let imageTensor=toInputTensor(input);imageTensor=tfjs.pad3d(imageTensor,[[padT,padB],[padL,padR],[0,0]]);return tfjs.image.resizeBilinear(imageTensor,[targetH,targetW])}));return{resized:resized,padding:{top:padT,left:padL,right:padR,bottom:padB}}}function scaleAndFlipPoses(poses,[height,width],[inputResolutionHeight,inputResolutionWidth],padding,flipHorizontal){const scaleY=(height+padding.top+padding.bottom)/inputResolutionHeight;const scaleX=(width+padding.left+padding.right)/inputResolutionWidth;const scaledPoses=scalePoses(poses,scaleY,scaleX,-padding.top,-padding.left);if(flipHorizontal){return flipPosesHorizontal(scaledPoses,width)}else{return scaledPoses}}const MOBILENET_V1_CONFIG={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:257};const VALID_ARCHITECTURE=["MobileNetV1","ResNet50"];const VALID_STRIDE={MobileNetV1:[8,16,32],ResNet50:[32,16]};const VALID_MULTIPLIER={MobileNetV1:[.5,.75,1],ResNet50:[1]};const VALID_QUANT_BYTES=[1,2,4];function validateModelConfig(config){config=config||MOBILENET_V1_CONFIG;if(config.architecture==null){config.architecture="MobileNetV1"}if(VALID_ARCHITECTURE.indexOf(config.architecture)<0){throw new Error(`Invalid architecture ${config.architecture}. Should be one of ${VALID_ARCHITECTURE}`)}if(config.inputResolution==null){config.inputResolution=257}validateInputResolution(config.inputResolution);if(config.outputStride==null){config.outputStride=16}if(VALID_STRIDE[config.architecture].indexOf(config.outputStride)<0){throw new Error(`Invalid outputStride ${config.outputStride}. Should be one of ${VALID_STRIDE[config.architecture]} for architecture ${config.architecture}.`)}if(config.multiplier==null){config.multiplier=1}if(VALID_MULTIPLIER[config.architecture].indexOf(config.multiplier)<0){throw new Error(`Invalid multiplier ${config.multiplier}. Should be one of ${VALID_MULTIPLIER[config.architecture]} for architecture ${config.architecture}.`)}if(config.quantBytes==null){config.quantBytes=4}if(VALID_QUANT_BYTES.indexOf(config.quantBytes)<0){throw new Error(`Invalid quantBytes ${config.quantBytes}. Should be one of ${VALID_QUANT_BYTES} for architecture ${config.architecture}.`)}if(config.architecture==="MobileNetV1"&&config.outputStride===32&&config.multiplier!==1){throw new Error(`When using an output stride of 32, you must select 1 as the multiplier.`)}return config}const SINGLE_PERSON_INFERENCE_CONFIG={flipHorizontal:false};const MULTI_PERSON_INFERENCE_CONFIG={flipHorizontal:false,maxDetections:5,scoreThreshold:.5,nmsRadius:20};function validateMultiPersonInputConfig(config){const{maxDetections:maxDetections,scoreThreshold:scoreThreshold,nmsRadius:nmsRadius}=config;if(maxDetections<=0){throw new Error(`Invalid maxDetections ${maxDetections}. Should be > 0`)}if(scoreThreshold<0||scoreThreshold>1){throw new Error(`Invalid scoreThreshold ${scoreThreshold}. Should be in range [0.0, 1.0]`)}if(nmsRadius<=0){throw new Error(`Invalid nmsRadius ${nmsRadius}.`)}}class PoseNet{constructor(net,inputResolution){assertValidOutputStride(net.outputStride);assertValidResolution(inputResolution,net.outputStride);this.baseModel=net;this.inputResolution=inputResolution}estimateMultiplePoses(input,config=MULTI_PERSON_INFERENCE_CONFIG){const configWithDefaults={...MULTI_PERSON_INFERENCE_CONFIG,...config};validateMultiPersonInputConfig(config);const outputStride=this.baseModel.outputStride;const inputResolution=this.inputResolution;const[height,width]=getInputTensorDimensions(input);const{resized:resized,padding:padding}=padAndResizeTo(input,inputResolution);const{heatmapScores:heatmapScores,offsets:offsets,displacementFwd:displacementFwd,displacementBwd:displacementBwd}=this.baseModel.predict(resized);const allTensorBuffers=toTensorBuffers3D([heatmapScores,offsets,displacementFwd,displacementBwd]);const scoresBuffer=allTensorBuffers[0];const offsetsBuffer=allTensorBuffers[1];const displacementsFwdBuffer=allTensorBuffers[2];const displacementsBwdBuffer=allTensorBuffers[3];const poses=decodeMultiplePoses(scoresBuffer,offsetsBuffer,displacementsFwdBuffer,displacementsBwdBuffer,outputStride,configWithDefaults.maxDetections,configWithDefaults.scoreThreshold,configWithDefaults.nmsRadius);const resultPoses=scaleAndFlipPoses(poses,[height,width],inputResolution,padding,configWithDefaults.flipHorizontal);heatmapScores.dispose();offsets.dispose();displacementFwd.dispose();displacementBwd.dispose();resized.dispose();return resultPoses}estimateSinglePose(input,config=SINGLE_PERSON_INFERENCE_CONFIG){const configWithDefaults={...SINGLE_PERSON_INFERENCE_CONFIG,...config};const outputStride=this.baseModel.outputStride;const inputResolution=this.inputResolution;const[height,width]=getInputTensorDimensions(input);const{resized:resized,padding:padding}=padAndResizeTo(input,inputResolution);const{heatmapScores:heatmapScores,offsets:offsets,displacementFwd:displacementFwd,displacementBwd:displacementBwd}=this.baseModel.predict(resized);const pose=decodeSinglePose(heatmapScores,offsets,outputStride);const poses=[pose];const resultPoses=scaleAndFlipPoses(poses,[height,width],inputResolution,padding,configWithDefaults.flipHorizontal);heatmapScores.dispose();offsets.dispose();displacementFwd.dispose();displacementBwd.dispose();resized.dispose();return resultPoses[0]}estimatePoses(input,config){if(config.decodingMethod==="single-person"){const pose=this.estimateSinglePose(input,config);return[pose]}else{return this.estimateMultiplePoses(input,config)}}dispose(){this.baseModel.dispose()}}async function loadMobileNet(config){const outputStride=config.outputStride;const quantBytes=config.quantBytes;const multiplier=config.multiplier;if(tfjs.tf==null){throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.`)}const url=mobileNetCheckpoint(outputStride,multiplier,quantBytes);const graphModel=await tfjs.loadGraphModel(config.modelUrl||url);const mobilenet=new MobileNet(graphModel,outputStride);const validInputResolution=getValidInputResolutionDimensions(config.inputResolution,mobilenet.outputStride);return new PoseNet(mobilenet,validInputResolution)}async function loadResNet(config){const outputStride=config.outputStride;const quantBytes=config.quantBytes;if(tfjs.tf==null){throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.`)}const url=resNet50Checkpoint(outputStride,quantBytes);const graphModel=await tfjs.loadGraphModel(config.modelUrl||url);const resnet=new ResNet(graphModel,outputStride);const validInputResolution=getValidInputResolutionDimensions(config.inputResolution,resnet.outputStride);return new PoseNet(resnet,validInputResolution)}async function load(config=MOBILENET_V1_CONFIG){config=validateModelConfig(config);if(config.architecture==="ResNet50"){return loadResNet(config)}else if(config.architecture==="MobileNetV1"){return loadMobileNet(config)}else{return null}}const color="aqua";const lineWidth=2;function toTuple({y:y,x:x}){return[y,x]}function drawPoint(ctx,y,x,r,color2){ctx.beginPath();ctx.arc(x,y,r,0,2*Math.PI);ctx.fillStyle=color2;ctx.fill()}function drawSegment([ay,ax],[by,bx],color2,scale,ctx){ctx.beginPath();ctx.moveTo(ax*scale,ay*scale);ctx.lineTo(bx*scale,by*scale);ctx.lineWidth=lineWidth;ctx.strokeStyle=color2;ctx.stroke()}function drawSkeleton(keypoints,minConfidence,ctx,scale=1){const adjacentKeyPoints=getAdjacentKeyPoints(keypoints,minConfidence);adjacentKeyPoints.forEach((keypoints2=>{drawSegment(toTuple(keypoints2[0].position),toTuple(keypoints2[1].position),color,scale,ctx)}))}function drawKeypoints(keypoints,minConfidence,ctx,scale=1){for(let i=0;i<keypoints.length;i++){const keypoint=keypoints[i];if(keypoint.score<minConfidence){continue}const{y:y,x:x}=keypoint.position;drawPoint(ctx,y*scale,x*scale,3,color)}}function drawPoses(poses,ctx){const minPoseConfidence=.3;const minPartConfidence=.3;poses.forEach((({score:score,keypoints:keypoints})=>{if(score>=minPoseConfidence){drawKeypoints(keypoints,minPartConfidence,ctx);drawSkeleton(keypoints,minPartConfidence,ctx)}}));return poses}const POSENET_URL="https://www.gstaticcnapps.cn/tfjs-models/savedmodel/posenet/mobilenet/float/050/model-stride16.json";Page({helper:null,async onReady(){await tfjs.ready();const helper=this.selectComponent("#helper");const model=await load({architecture:"MobileNetV1",outputStride:16,inputResolution:193,multiplier:.5,modelUrl:POSENET_URL});console.log("posenet load end");const onFrame=(frame,deps)=>{const{ctx:ctx}=deps;const video={width:frame.width,height:frame.height,data:new Uint8Array(frame.data)};const t=Date.now();const prediction=model.estimateSinglePose(video,{flipHorizontal:false});console.log("predict cost",Date.now()-t);helper.drawCanvas2D(frame);drawPoses([prediction],ctx)};helper.set({onFrame:onFrame});this.helper=helper},onShow:function(){var _a;(_a=this.helper)==null?void 0:_a.start()},onHide:function(){var _a;(_a=this.helper)==null?void 0:_a.stop()},onUnload:function(){}});
